#!/usr/bin/env python3
"""
PyInstaller build script for ONFRA PFAS application.

Generates spec files and builds the application for the current platform.
"""

from __future__ import annotations

import argparse
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path


# Project paths
PROJECT_ROOT = Path(__file__).parent.parent
SRC_DIR = PROJECT_ROOT / "src"
ASSETS_DIR = PROJECT_ROOT / "assets"
DIST_DIR = PROJECT_ROOT / "dist"
BUILD_DIR = PROJECT_ROOT / "build"

# Application info
APP_NAME = "ONFRA_PFAS"
MAIN_SCRIPT = SRC_DIR / "onfra_pfas" / "app" / "main.py"
ICON_FILE = ASSETS_DIR / "onfra_logo.png"


def get_separator() -> str:
    """Get path separator for add-data based on OS."""
    return ";" if platform.system() == "Windows" else ":"


def get_icon_option() -> list[str]:
    """Get icon option based on OS."""
    if not ICON_FILE.exists():
        return []

    system = platform.system()

    if system == "Windows":
        # Would need to convert PNG to ICO for Windows
        # For now, skip icon on Windows unless ICO exists
        ico_file = ASSETS_DIR / "onfra_logo.ico"
        if ico_file.exists():
            return ["--icon", str(ico_file)]
        return []

    elif system == "Darwin":
        # macOS uses ICNS
        icns_file = ASSETS_DIR / "onfra_logo.icns"
        if icns_file.exists():
            return ["--icon", str(icns_file)]
        return []

    return []


def generate_spec_file(mode: str = "onedir") -> Path:
    """
    Generate PyInstaller spec file.

    Args:
        mode: "onedir" or "onefile"

    Returns:
        Path to generated spec file
    """
    sep = get_separator()

    # Data files to include
    datas = [
        (str(ASSETS_DIR / "onfra_logo.png"), "assets"),
    ]

    # Hidden imports for pyopenms and other dependencies
    hidden_imports = [
        "pyopenms",
        "PySide6.QtWebEngineWidgets",
        "pandas",
        "numpy",
        "pyarrow",
        "yaml",
        "jinja2",
    ]

    # Try to detect if cupy is installed
    try:
        import cupy
        hidden_imports.append("cupy")
    except ImportError:
        pass

    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller spec file for ONFRA PFAS.
Generated by build_pyinstaller.py
"""

block_cipher = None

a = Analysis(
    [r'{MAIN_SCRIPT}'],
    pathex=[r'{SRC_DIR}'],
    binaries=[],
    datas={datas!r},
    hiddenimports={hidden_imports!r},
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
'''

    if mode == "onefile":
        spec_content += f'''
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{APP_NAME}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
'''
    else:  # onedir
        spec_content += f'''
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{APP_NAME}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='{APP_NAME}',
)
'''

    # Write spec file
    spec_path = PROJECT_ROOT / f"{APP_NAME}_{mode}.spec"
    with open(spec_path, "w", encoding="utf-8") as f:
        f.write(spec_content)

    print(f"Generated spec file: {spec_path}")
    return spec_path


def build_with_pyinstaller(
    mode: str = "onedir",
    use_spec: bool = True,
    clean: bool = True,
) -> bool:
    """
    Build application with PyInstaller.

    Args:
        mode: "onedir" or "onefile"
        use_spec: Use spec file (True) or command line (False)
        clean: Clean build directories first

    Returns:
        True if build succeeded
    """
    # Clean previous builds
    if clean:
        for dir_path in [BUILD_DIR, DIST_DIR]:
            if dir_path.exists():
                print(f"Cleaning {dir_path}...")
                shutil.rmtree(dir_path)

    if use_spec:
        # Generate and use spec file
        spec_path = generate_spec_file(mode)
        cmd = [
            sys.executable, "-m", "PyInstaller",
            "-y", "--noconfirm",
            str(spec_path),
        ]
    else:
        # Use command line
        sep = get_separator()
        cmd = [
            sys.executable, "-m", "PyInstaller",
            "-y", "--noconfirm",
            f"--{mode}",
            "--windowed",
            "--name", APP_NAME,
            f"--add-data", f"{ASSETS_DIR / 'onfra_logo.png'}{sep}assets",
        ]

        # Add icon if available
        cmd.extend(get_icon_option())

        # Add main script
        cmd.append(str(MAIN_SCRIPT))

    print(f"Running: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, cwd=PROJECT_ROOT, check=True)
        print(f"\n✓ Build complete! Output in: {DIST_DIR / APP_NAME}")
        return True

    except subprocess.CalledProcessError as e:
        print(f"\n✗ Build failed with exit code {e.returncode}")
        return False


def verify_build() -> bool:
    """Verify the build output."""
    if platform.system() == "Windows":
        exe_path = DIST_DIR / APP_NAME / f"{APP_NAME}.exe"
    else:
        exe_path = DIST_DIR / APP_NAME / APP_NAME

    if not exe_path.exists():
        print(f"✗ Executable not found: {exe_path}")
        return False

    print(f"✓ Executable found: {exe_path}")

    # Check for assets
    assets_path = DIST_DIR / APP_NAME / "assets" / "onfra_logo.png"
    if platform.system() == "Darwin":
        # macOS bundle structure is different
        assets_path = DIST_DIR / APP_NAME / "_internal" / "assets" / "onfra_logo.png"

    # Try common locations
    possible_asset_paths = [
        DIST_DIR / APP_NAME / "assets" / "onfra_logo.png",
        DIST_DIR / APP_NAME / "_internal" / "assets" / "onfra_logo.png",
    ]

    asset_found = any(p.exists() for p in possible_asset_paths)
    if asset_found:
        print("✓ Assets included")
    else:
        print("⚠ Assets may not be properly included")

    return True


def check_dependencies() -> bool:
    """Check if required dependencies are available."""
    checks = []

    # Check PyInstaller
    try:
        import PyInstaller
        checks.append(("PyInstaller", PyInstaller.__version__, True))
    except ImportError:
        checks.append(("PyInstaller", "Not installed", False))

    # Check pyOpenMS
    try:
        import pyopenms
        checks.append(("pyOpenMS", pyopenms.__version__, True))
    except ImportError:
        checks.append(("pyOpenMS", "Not installed", False))

    # Check PySide6
    try:
        from PySide6 import __version__ as pyside_version
        checks.append(("PySide6", pyside_version, True))
    except ImportError:
        checks.append(("PySide6", "Not installed", False))

    # Print results
    print("\nDependency check:")
    all_ok = True
    for name, version, ok in checks:
        status = "✓" if ok else "✗"
        print(f"  {status} {name}: {version}")
        if not ok:
            all_ok = False

    return all_ok


def main():
    parser = argparse.ArgumentParser(description="Build ONFRA PFAS application")
    parser.add_argument(
        "--mode",
        choices=["onedir", "onefile"],
        default="onedir",
        help="Build mode (default: onedir)",
    )
    parser.add_argument(
        "--no-spec",
        action="store_true",
        help="Don't use spec file, use command line directly",
    )
    parser.add_argument(
        "--no-clean",
        action="store_true",
        help="Don't clean previous builds",
    )
    parser.add_argument(
        "--check-deps",
        action="store_true",
        help="Only check dependencies",
    )
    parser.add_argument(
        "--generate-spec",
        action="store_true",
        help="Only generate spec file",
    )

    args = parser.parse_args()

    print(f"ONFRA PFAS Build Script")
    print(f"Platform: {platform.system()} {platform.machine()}")
    print(f"Python: {sys.version}")
    print()

    # Check dependencies
    if not check_dependencies():
        if not args.check_deps:
            print("\n⚠ Some dependencies are missing. Build may fail.")
    else:
        print("\n✓ All dependencies available")

    if args.check_deps:
        return

    # Generate spec only
    if args.generate_spec:
        generate_spec_file(args.mode)
        return

    # Run build
    print(f"\nBuilding in {args.mode} mode...")

    success = build_with_pyinstaller(
        mode=args.mode,
        use_spec=not args.no_spec,
        clean=not args.no_clean,
    )

    if success:
        verify_build()
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
